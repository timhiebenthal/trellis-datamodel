## Data model and file structure best practices

This project bridges conceptual/logical data modeling with physical dbt implementation using YAML files. It does NOT use traditional database models or ORMs.

### Architecture Overview
- **Read**: dbt artifacts (manifest.json, catalog.json) for physical implementation details
- **Store**: Conceptual/logical data model in `data_model.yml` (entities, relationships, metadata)
- **Store**: Canvas visual layout in `canvas_layout.yml` (positions, sizes, collapsed state)
- **Write**: Back to dbt `schema.yml` files (descriptions, tags, relationship tests)

### data_model.yml (Conceptual/Logical Layer)
- **Purpose**: Stores business-level entity definitions, relationships, and metadata
- **Content**: 
  - Entity definitions (id, label, description, tags)
  - Entity-to-dbt-model bindings (dbt_model, additional_models)
  - Drafted fields (fields defined before SQL exists)
  - Relationships between entities (source, target, type, fields)
- **Handling**: Use standard `yaml` library (pyyaml) for reading/writing
- **Location**: Configurable via `data_model_file` in `trellis.yml`, defaults to `data_model.yml` in dbt project root
- **Separation**: Does NOT contain visual/layout properties (those go in canvas_layout.yml)

### canvas_layout.yml (Visual Layer)
- **Purpose**: Stores canvas-specific visual properties separate from business logic
- **Content**:
  - Entity positions, widths, panel heights, collapsed states
  - Relationship label offsets (label_dx, label_dy)
- **Handling**: Use standard `yaml` library (pyyaml) for reading/writing
- **Location**: Automatically placed next to `data_model.yml` (e.g., `canvas_layout.yml`)
- **Merging**: Backend merges layout data into model data when serving to frontend

### Pydantic Schemas (API Layer)
- **Schema Location**: Define Pydantic models in `trellis_datamodel/models/schemas.py`
- **Purpose**: Validate API request/response data (not database models)
- **Clear Naming**: Use descriptive class names (e.g., `DataModelUpdate`, `EntityUpdate`)
- **Type Hints**: Use proper type hints including Optional, List, Dict from typing module
- **Validation**: Leverage Pydantic's built-in validation for data integrity
- **Serialization**: Ensure models are JSON-serializable for API responses

### dbt Artifacts (Read-Only Physical Layer)
- **manifest.json**: Contains dbt model definitions, dependencies, and metadata
- **catalog.json**: Contains column information and types from database introspection
- **Reading**: Parse JSON artifacts to understand physical implementation
- **Never Modify**: These are generated by `dbt docs generate`, never edit them directly
